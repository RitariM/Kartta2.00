
<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Karttaruudukko</title>
<style>
  body { font-family: sans-serif; text-align: center; margin: 20px; }
  canvas { max-width: 100%; height: auto; border: 1px solid #ccc; touch-action: none; }
  #hoverInfo { margin-top: 10px; font-weight: bold; color: green; }
</style>
</head>
<body>
<h1>Karttaruudukko</h1>
<input type="file" id="fileInput" accept="image/*"/><br/>
<label>
Rivit:
<input type="range" id="rowsSlider" min="1" max="26" value="20"/>
<span id="rowsValue">20</span>
</label><br/>
<label>
Sarakkeet:
<input type="range" id="colsSlider" min="1" max="20" value="20"/>
<span id="colsValue">20</span>
</label><br/>
<button id="downloadBtn" disabled>Lataa</button>
<button id="resetBtn">Tyhjennä</button>
<button id="redoBtn" disabled>Muokkaa</button>
<canvas id="canvas"></canvas>
<div id="hoverInfo"></div>

<script src="https://cdn.jsdelivr.net/npm/[email protected]/exif.min.js"></script>
<script>
const fileInput = document.getElementById("fileInput"),
  canvas = document.getElementById("canvas"),
  ctx = canvas.getContext("2d"),
  rowsSlider = document.getElementById("rowsSlider"),
  colsSlider = document.getElementById("colsSlider"),
  rowsValue = document.getElementById("rowsValue"),
  colsValue = document.getElementById("colsValue"),
  downloadBtn = document.getElementById("downloadBtn"),
  resetBtn = document.getElementById("resetBtn"),
  redoBtn = document.getElementById("redoBtn"),
  hoverInfo = document.getElementById("hoverInfo");

let img = new Image(),
    selectionBox = null,
    prevBox = null,
    dragging = false,
    moving = false,
    confirmed = false,
    zoom = 1,
    offX = 0,
    offY = 0,
    panning = false,
    panX = 0,
    panY = 0;

fileInput.onchange = () => {
  const file = fileInput.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function (e) {
    img = new Image();
    img.onload = () => {
      EXIF.getData(file, function () {
        const orientation = EXIF.getTag(this, "Orientation") || 1;
        fixOrientation(img, orientation).then((fixedImg) => {
          // Skaalaa kuva automaattisesti näkymään
          const maxWidth = window.innerWidth * 0.95;
          const maxHeight = window.innerHeight * 0.6;
          zoom = Math.min(maxWidth / fixedImg.width, maxHeight / fixedImg.height, 1);
          canvas.width = fixedImg.width * zoom;
          canvas.height = fixedImg.height * zoom;
          ctx.setTransform(zoom, 0, 0, zoom, 0, 0);
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(fixedImg, 0, 0);
          img = fixedImg;
        });
      });
    };
    img.src = e.target.result;
  };
  reader.readAsDataURL(file);
};

function fixOrientation(img, orientation) {
  return new Promise((resolve) => {
    const canvasTmp = document.createElement("canvas");
    const ctxTmp = canvasTmp.getContext("2d");
    const w = img.width;
    const h = img.height;

    if ([5, 6, 7, 8].includes(orientation)) {
      canvasTmp.width = h;
      canvasTmp.height = w;
    } else {
      canvasTmp.width = w;
      canvasTmp.height = h;
    }

    switch (orientation) {
      case 2: ctxTmp.transform(-1, 0, 0, 1, w, 0); break;
      case 3: ctxTmp.transform(-1, 0, 0, -1, w, h); break;
      case 4: ctxTmp.transform(1, 0, 0, -1, 0, h); break;
      case 5: ctxTmp.transform(0, 1, 1, 0, 0, 0); break;
      case 6: ctxTmp.transform(0, 1, -1, 0, h, 0); break;
      case 7: ctxTmp.transform(0, -1, -1, 0, h, w); break;
      case 8: ctxTmp.transform(0, -1, 1, 0, 0, w); break;
    }

    ctxTmp.drawImage(img, 0, 0);
    const fixedImg = new Image();
    fixedImg.onload = () => resolve(fixedImg);
    fixedImg.src = canvasTmp.toDataURL();
  });
}

canvas.addEventListener("touchstart", (e) => {
  if (e.touches.length === 1 && !confirmed) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.touches[0].clientX - rect.left - offX) / zoom;
    const y = (e.touches[0].clientY - rect.top - offY) / zoom;
    selectionBox = { x, y, width: 0, height: 0 };
    dragging = true;
  }
});

canvas.addEventListener("touchmove", (e) => {
  if (dragging && e.touches.length === 1) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = (e.touches[0].clientX - rect.left - offX) / zoom;
    const y = (e.touches[0].clientY - rect.top - offY) / zoom;
    selectionBox.width = x - selectionBox.x;
    selectionBox.height = y - selectionBox.y;
    drawImage();
  }
});

canvas.addEventListener("touchend", (e) => {
  if (dragging) {
    dragging = false;
    normalize(selectionBox);
    prevBox = { ...selectionBox };
    confirmed = true;
    downloadBtn.disabled = redoBtn.disabled = false;
    drawGrid(selectionBox);
  }
});

function drawImage() {
  ctx.setTransform(zoom, 0, 0, zoom, offX, offY);
  ctx.clearRect(0, 0, canvas.width / zoom, canvas.height / zoom);
  if (img.src) ctx.drawImage(img, 0, 0);
  if (selectionBox) {
    ctx.beginPath();
    ctx.setLineDash([5, 5]);
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 2 / zoom;
    ctx.rect(selectionBox.x, selectionBox.y, selectionBox.width, selectionBox.height);
    ctx.stroke();
  }
}

function drawGrid(c) {
  normalize(c);
  const cols = +colsSlider.value, rows = +rowsSlider.value;
  const cw = c.width / cols, ch = c.height / rows;
  canvas.width = c.width;
  canvas.height = c.height;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(img, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height);
  ctx.strokeStyle = "rgba(0,0,0,0.5)";
  for (let i = 0; i <= cols; i++) {
    ctx.beginPath(); ctx.moveTo(i * cw, 0); ctx.lineTo(i * cw, c.height); ctx.stroke();
  }
  for (let j = 0; j <= rows; j++) {
    ctx.beginPath(); ctx.moveTo(0, j * ch); ctx.lineTo(c.width, j * ch); ctx.stroke();
  }
}

function normalize(b) {
  if (b.width < 0) { b.x += b.width; b.width = -b.width; }
  if (b.height < 0) { b.y += b.height; b.height = -b.height; }
}
</script>
</body>
</html>
