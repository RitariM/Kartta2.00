<!DOCTYPE html>
<html lang="fi">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Karttaruudukko</title>
<style>body{font-family:sans-serif;text-align:center;margin:20px}canvas{max-width:100%;height:auto;border:1px solid #ccc;touch-action:none}#hoverInfo{margin-top:10px;font-weight:bold;color:green}</style>
</head>
<body>
<h1>Karttaruudukko</h1>
<input type="file" id="fileInput" accept="image/*"/><br/>
<label>
Rivit:
<input type="range" id="rowsSlider" min="1" max="26" value="20"/>
<span id="rowsValue">20</span>
</label><br/>
<label>
Sarakkeet:
<input type="range" id="colsSlider" min="1" max="20" value="20"/>
<span id="colsValue">20</span>
</label><br/>
<button id="downloadBtn" disabled>Lataa</button>
<button id="resetBtn">Tyhjennä</button>
<button id="redoBtn" disabled>Muokkaa</button>
<canvas id="canvas"></canvas>
<div id="hoverInfo"></div>
<!-- EXIF library for orientation -->
<script src="https://cdn.jsdelivr.net/npm/[email protected]/exif.min.js"></script>
<script>
      const fileInput = document.getElementById("fileInput"),
        canvas = document.getElementById("canvas"),
        ctx = canvas.getContext("2d"),
        rowsSlider = document.getElementById("rowsSlider"),
        colsSlider = document.getElementById("colsSlider"),
        rowsValue = document.getElementById("rowsValue"),
        colsValue = document.getElementById("colsValue"),
        downloadBtn = document.getElementById("downloadBtn"),
        resetBtn = document.getElementById("resetBtn"),
        redoBtn = document.getElementById("redoBtn"),
        hoverInfo = document.getElementById("hoverInfo");

      let img = new Image(),
        selectionBox = null,
        prevBox = null;
      let dragging = false,
        moving = false,
        confirmed = false;
      let zoom = 1,
        offX = 0,
        offY = 0,
        panning = false,
        panX = 0,
        panY = 0;

      fileInput.onchange = () => {
        const file = fileInput.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
          img = new Image();
          img.onload = () => {
            EXIF.getData(file, function () {
              const orientation = EXIF.getTag(this, "Orientation") || 1;
              fixOrientation(img, orientation).then((fixedImg) => {
                canvas.width = fixedImg.width;
                canvas.height = fixedImg.height;
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(fixedImg, 0, 0);
                // img.src = canvas.toDataURL(); // Poistettu iPhone-yhteensopivuuden parantamiseksi
                img.onload = () => {
                  offX = offY = 0;
                  zoom = 1;
                  resetAll();
                  drawImage();
                };
              });
            });
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      };

      // Fix image orientation asynchronously (returns a Promise)
      function fixOrientation(img, orientation) {
        return new Promise((resolve) => {
          const canvasTmp = document.createElement("canvas");
          const ctxTmp = canvasTmp.getContext("2d");
          const w = img.width;
          const h = img.height;

          if ([5, 6, 7, 8].indexOf(orientation) > -1) {
            canvasTmp.width = h;
            canvasTmp.height = w;
          } else {
            canvasTmp.width = w;
            canvasTmp.height = h;
          }

          switch (orientation) {
            case 2:
              ctxTmp.transform(-1, 0, 0, 1, w, 0);
              break; // Flip X
            case 3:
              ctxTmp.transform(-1, 0, 0, -1, w, h);
              break; // Rotate 180
            case 4:
              ctxTmp.transform(1, 0, 0, -1, 0, h);
              break; // Flip Y
            case 5:
              ctxTmp.transform(0, 1, 1, 0, 0, 0);
              break; // Transpose
            case 6:
              ctxTmp.transform(0, 1, -1, 0, h, 0);
              break; // Rotate 90
            case 7:
              ctxTmp.transform(0, -1, -1, 0, h, w);
              break; // Transverse
            case 8:
              ctxTmp.transform(0, -1, 1, 0, 0, w);
              break; // Rotate -90
            default:
              break;
          }

          ctxTmp.drawImage(img, 0, 0);
          const fixedImg = new Image();
          fixedImg.onload = () => resolve(fixedImg);
          fixedImg.src = canvasTmp.toDataURL();
        });
      }

      rowsSlider.oninput = () => {
        rowsValue.textContent = rowsSlider.value;
        if (confirmed) drawGrid(selectionBox);
      };
      colsSlider.oninput = () => {
        colsValue.textContent = colsSlider.value;
        if (confirmed) drawGrid(selectionBox);
      };

      canvas.onmousedown = (e) => {
        const r = canvas.getBoundingClientRect(),
          x = (e.clientX - r.left - offX) / zoom,
          y = (e.clientY - r.top - offY) / zoom;
        if (e.button === 1 || (e.button === 0 && e.altKey)) {
          panning = true;
          panX = e.clientX - offX;
          panY = e.clientY - offY;
          return;
        }
        if (confirmed) return;
        if (
          selectionBox &&
          x >= selectionBox.x &&
          x <= selectionBox.x + selectionBox.width &&
          y >= selectionBox.y &&
          y <= selectionBox.y + selectionBox.height
        )
          (moving = true), (panX = x), (panY = y);
        else {
          dragging = true;
          selectionBox = { x, y, width: 0, height: 0 };
        }
      };

      canvas.onmousemove = (e) => {
        const r = canvas.getBoundingClientRect(),
          x = (e.clientX - r.left - offX) / zoom,
          y = (e.clientY - r.top - offY) / zoom;
        if (dragging) {
          selectionBox.width = x - selectionBox.x;
          selectionBox.height = y - selectionBox.y;
          drawImage();
        } else if (moving) {
          selectionBox.x += x - panX;
          selectionBox.y += y - panY;
          panX = x;
          panY = y;
          drawImage();
        } else if (panning) {
          offX = e.clientX - panX;
          offY = e.clientY - panY;
          drawImage();
        }
        if (confirmed) hoverCell(x, y);
      };

      canvas.onmouseup = () => {
        if (dragging || moving) {
          dragging = moving = false;
          normalize(selectionBox);
          prevBox = { ...selectionBox };
          confirmed = true;
          downloadBtn.disabled = redoBtn.disabled = false;
          drawGrid(selectionBox);
        }
        panning = false;
      };

      canvas.onwheel = (e) => {
        e.preventDefault();
        const r = canvas.getBoundingClientRect(),
          mx = e.clientX - r.left,
          my = e.clientY - r.top,
          prev = zoom;
        zoom = Math.min(Math.max(zoom - e.deltaY * 0.001, 0.5), 4);
        offX = mx - (mx - offX) * (zoom / prev);
        offY = my - (my - offY) * (zoom / prev);
        drawImage();
      };

      canvas.ontouchstart = (e) => {
        if (e.touches.length === 2) {
          panning = true;
          panX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - offX;
          panY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - offY;
        }
      };

      canvas.ontouchmove = (e) => {
        if (panning && e.touches.length === 2) {
          e.preventDefault();
          offX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - panX;
          offY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - panY;
          drawImage();
        }
      };

      canvas.ontouchend = () => {
        panning = false;
      };

      downloadBtn.onclick = () => {
        const a = document.createElement("a");
        a.href = canvas.toDataURL();
        a.download = "karttaruudukko.png";
        a.click();
      };

      resetBtn.onclick = resetAll;
      redoBtn.onclick = () => {
        if (prevBox) {
          selectionBox = { ...prevBox };
          drawGrid(selectionBox);
        }
      };

      function resetAll() {
        selectionBox = prevBox = null;
        confirmed = false;
        downloadBtn.disabled = redoBtn.disabled = true;
        hoverInfo.textContent = "";
        drawImage();
      }

      function drawImage() {
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.setTransform(zoom, 0, 0, zoom, offX, offY);
        if (img.src) ctx.drawImage(img, 0, 0);
        if (selectionBox) {
          ctx.beginPath();
          ctx.setLineDash([5, 5]);
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 2 / zoom;
          ctx.rect(
            selectionBox.x,
            selectionBox.y,
            selectionBox.width,
            selectionBox.height
          );
          ctx.stroke();
        }
      }

      function drawGrid(c) {
        normalize(c);
        canvas.width = c.width;
        canvas.height = c.height;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, c.x, c.y, c.width, c.height, 0, 0, c.width, c.height);
        const cols = +colsSlider.value,
          rows = +rowsSlider.value;
        const cw = c.width / cols,
          ch = c.height / rows;
        ctx.strokeStyle = "rgba(0,0,0,0.5)";
        for (let i = 0; i <= cols; i++) {
          ctx.beginPath();
          ctx.moveTo(i * cw, 0);
          ctx.lineTo(i * cw, c.height);
          ctx.stroke();
        }
        for (let j = 0; j <= rows; j++) {
          ctx.beginPath();
          ctx.moveTo(0, j * ch);
          ctx.lineTo(c.width, j * ch);
          ctx.stroke();
        }
        ctx.fillStyle = "#0f0";
        ctx.font = `${Math.min(cw, ch) / 3}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        for (let i = 0; i < cols; i++)
          ctx.fillText(i + 1, (i + 0.5) * cw, ch * 0.2);
        const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        for (let j = 0; j < rows; j++)
          ctx.fillText(letters[j], cw * 0.2, (j + 0.5) * ch);
      }

      function hoverCell(x, y) {
        const c = selectionBox;
        if (!c) return;
        if (x >= c.x && x <= c.x + c.width && y >= c.y && y <= c.y + c.height) {
          const col = Math.floor(((x - c.x) * colsSlider.value) / c.width) + 1;
          const row =
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[
              Math.floor(((y - c.y) * rowsSlider.value) / c.height)
            ];
          hoverInfo.textContent = `Rivi: ${row}, Sarake: ${col}`;
        } else hoverInfo.textContent = "";
      }

      function normalize(b) {
        if (!b) return;
        if (b.width < 0) {
          b.x += b.width;
          b.width = -b.width;
        }
        if (b.height < 0) {
          b.y += b.height;
          b.height = -b.height;
        }
      }
    </script>
</body>
</html>